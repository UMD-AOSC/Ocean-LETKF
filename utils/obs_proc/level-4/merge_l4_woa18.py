#!/usr/bin/env python3

import datetime as dt
import calendar
import argparse
import os, sys
import numpy as np
import xesmf as xe
from netCDF4 import Dataset
from regrid_tools import fill_nan_grds_aux, iterative_fill_POP_core

def parseCommandLine():
    parser = argparse.ArgumentParser(description=("Generate regrid weight file by xesmf"))
    parser.add_argument("--regridder_file_path", required=True, help=(
                "path to store the regridder file generated by xesmf"))
    parser.add_argument("--target_grid_path",required=True, help=(
                "path of the target grid file (e.g., MOM6)"))
    parser.add_argument("--source_grid_path", required=True, help=(
                "path of the source grid file (e.g., WOA18)"))
    parser.add_argument("--woa18_filled_path", required=True, help=(
                    "path of the source grid file (e.g., WOA18)"))
    parser.add_argument("--l4_sss_path", required=True, help=(
                    "l4_sss_file"))
    parser.add_argument("--radius", required=True, type=int, help=(
                    "radius"))
    args = parser.parse_args()
    print(args)

    return args


def read_l4_sss_esacci(ds_path):
    f = Dataset(ds_path)
    delta_t  = f.variables['time'][:][0]
    sss = np.squeeze( f.variables['sss'][:] )
    sss_qc = np.squeeze( f.variables['sss_qc'][:] )
    lsc_qc = np.squeeze( f.variables['lsc_qc'][:] )
    isc_qc = np.squeeze( f.variables['isc_qc'][:] )
    f.close()
    t0 = dt.datetime(1970,1,1,0,0,0)
    t = t0 + dt.timedelta(days = int(delta_t))

    return sss, t, sss_qc, lsc_qc, isc_qc


def read_monthly_woa18_filled(ds_path,varname='SALT'):
    f = Dataset(ds_path)
    sss_12mn = f.variables[varname][:]
    f.close()

    return sss_12mn

def woa_month_to_day(woa_12mn, date):
    month_prev = date.month 
    month_next = date.month + 1 if date.month < 12 else 1
    imn_prev = month_prev - 1
    imn_next = month_next - 1

    ndays_total = calendar.monthrange(date.year,date.month)[1]
    print("ndays_total:", ndays_total, date.day)
    wts_prev = 1.0 - (date.day-1)/ndays_total
    wts_next = 1.0 - wts_prev
    print("wts_prev, wts_next", wts_prev, wts_next)

    woa_daily = wts_prev*woa_12mn[imn_prev,:,:] + wts_next*woa_12mn[imn_next,:,:]

    return woa_daily    


def main(args):

    debug = True


    #
    # load regridder info
    #

    # read in output WOA18 lon, lat
    f = Dataset(args.target_grid_path)
    lat1d_grd_out = f.variables['lat'][:]
    lon1d_grd_out = f.variables['lon'][:]
    f.close()

    # read in the input L4 lon, lat
    f = Dataset(args.source_grid_path)
    lat1d_grd_in = f.variables['lat'][:]
    lon1d_grd_in = f.variables['lon'][:]
    f.close()

    # we only generate wts to WOA18 grids within the L4 grid range; otherwise, xesmf fails to work
    lat_max_allowed = lat1d_grd_out[lat1d_grd_out<lat1d_grd_in.max()][-1]
    idx_lat_max_allowed = np.where(lat1d_grd_out==lat_max_allowed)[0][0]

    lat_min_allowed = lat1d_grd_out[lat1d_grd_out>lat1d_grd_in.min()][0]
    idx_lat_min_allowed = np.where(lat1d_grd_out==lat_min_allowed)[0][0]
    lat1d_grd_out_allowed = lat1d_grd_out[idx_lat_min_allowed:idx_lat_max_allowed+1]

    print("min_WOA18_lat can be mapped from L4 ESA: idx_woa18, val_woa18=", idx_lat_min_allowed, lat1d_grd_out[idx_lat_min_allowed])
    print("max_WOA18_lat can be mapped from L4 ESA: idx_woa18, val_woa18=", idx_lat_max_allowed, lat1d_grd_out[idx_lat_max_allowed])

    # generate the regridder
    grd_in = {"lon": lon1d_grd_in, "lat": lat1d_grd_in}
    grd_out = {"lon": lon1d_grd_out, "lat": lat1d_grd_out[idx_lat_min_allowed:idx_lat_max_allowed+1]}

    interp_method = "bilinear"
    periodic = True
    fn_regridder_in = os.path.abspath(args.regridder_file_path)
    regridder = xe.Regridder(grd_in, grd_out, interp_method, weights=fn_regridder_in, periodic=periodic)
    regridder.filename = fn_regridder_in  # a bug of xesmf 
    print(regridder)


    # read in daily L4 SSS
    sss_l4, date_l4, sss_qc, lsc_qc, isc_qc = read_l4_sss_esacci(args.l4_sss_path)
    if debug:
        print("sss_l4: shape, min, max", sss_l4.shape, sss_l4.min(), sss_l4.max())
        print("date_l4", date_l4)
    all_qc = sss_qc + lsc_qc + isc_qc

    # read in monthly WOA files
    sss_12mn_woa = read_monthly_woa18_filled(args.woa18_filled_path)
    if debug:
        for i in range(0,12):
            print(i, sss_12mn_woa[i,:,:].min(), sss_12mn_woa[i,:,:].max())

    # create daily WOA18 SSS using monthly WOA18
    sss_daily_woa = woa_month_to_day(sss_12mn_woa, date_l4)

    # interp L4 SSS to WOA18 grids using regridder (sss_l4 destroyed)
    # output is interped L4 SSS with land unfilled
    QC_GOOD = 0
    sss_l4[all_qc!=QC_GOOD] = np.nan
    sss_l4[sss_l4.mask] = np.nan
    sss_l4.mask = False
    sss_l4.fill_value = 0

    #wk2d = np.zeros((lat1d_grd_out_allowed.size,lon1d_grd_out.size))
    #wk2d[:,:] = regridder(sss_l4)
    wk2d = np.empty((lat1d_grd_out.size,lon1d_grd_out.size))
    wk2d[:,:] = np.nan
    wk2d[idx_lat_min_allowed:idx_lat_max_allowed+1,:] = regridder(sss_l4)

    sss_unfilled = wk2d.copy()

    # fill the grids whose nearby have no L4SSS 
    wk2d = fill_nan_grds_aux(wk2d, sss_daily_woa.data, args.radius)

    # merge 2 datasets
    # write out output on WOA18 filled grids
    

if __name__ == '__main__':
    args = parseCommandLine()
    main(args)

