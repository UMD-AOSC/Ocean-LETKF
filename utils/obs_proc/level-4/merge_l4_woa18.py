#!/usr/bin/env python3

import datetime as dt
import calendar
import argparse
import os, sys
import numpy as np
import xesmf as xe
from netCDF4 import Dataset
from regrid_tools import fill_nan_grds_aux, iterative_fill_POP_core

def parseCommandLine():
    parser = argparse.ArgumentParser(description=("Generate regrid weight file by xesmf"))
    parser.add_argument("--regridder_l4_to_woa_path", required=True, help=(
                "path to store the regridder file generated by xesmf"))
    parser.add_argument("--regridder_woa_to_mom_path", required=True, help=(
                "path to store the regridder file generated by xesmf"))
    parser.add_argument("--woa_grid_path",required=True, help=(
                "path of the target grid file (e.g., woa)"))
    parser.add_argument("--l4_grid_path", required=True, help=(
                "path of the source grid file (e.g., L4 SSS)"))
    parser.add_argument("--mom_grid_path", required=True, help=(
                "path of the source grid file (e.g., mom grids)"))
    parser.add_argument("--mom_lsmsk_path", required=True, help=(
                "path of the MOM land/sea mask"))
    parser.add_argument("--woa18_filled_path", required=True, help=(
                    "path of the source grid file (e.g., WOA18)"))
    parser.add_argument("--l4_sss_path", required=True, help=(
                    "l4_sss_file"))
    parser.add_argument("--radius", required=True, type=int, help=(
                    "radius"))
    parser.add_argument("--output_file_name", required=True, type=str, help=(
                    "output file name"))
    args = parser.parse_args()
    print(args)

    return args


def write_nc_file(fnout, lat1d_woa, lon1d_woa, lat2d_mom, lon2d_mom, \
                    sss_unfilled, sss_filled_step1, sss_filled_step2, sss_remapped_mom, wet_mom):
    print("write out netcdf file: {}".format(fnout))
    if os.path.exists(fnout):
        raise Exception("fnout already exists at: {}".format(fnout))
        sys.exit(2)

    fnout = os.path.abspath(fnout)
    f = Dataset(fnout, mode='w', format='NETCDF4_CLASSIC')
    f.createDimension('lat_woa', lat1d_woa.size)
    f.createDimension('lon_woa', lon1d_woa.size)
    f.createDimension('lat_mom', lat2d_mom.shape[0])
    f.createDimension('lon_mom', lat2d_mom.shape[1])

    lat1d_woa_to_file = f.createVariable('lat1d_woa',np.float32, ('lat_woa',))
    lon1d_woa_to_file = f.createVariable('lon1d_woa',np.float32, ('lon_woa',))
    lat2d_mom_to_file = f.createVariable('lat2d_mom',np.float32, ('lat_mom','lon_mom'))
    lon2d_mom_to_file = f.createVariable('lon2d_mom',np.float32, ('lat_mom','lon_mom'))

    unfill_to_file    = f.createVariable('sss_unfilled',    np.float32, ('lat_woa','lon_woa'))
    filled_s1_to_file = f.createVariable('sss_filled_step1',np.float32, ('lat_woa','lon_woa'))
    filled_s2_to_file = f.createVariable('sss_filled_step2',np.float32, ('lat_woa','lon_woa'))
    remapped_to_file  = f.createVariable('sss_remapped_mom',np.float32, ('lat_mom','lon_mom'))
    wet_to_file       = f.createVariable('wet',             np.float32, ('lat_mom','lon_mom'))

    lat1d_woa_to_file[:] = lat1d_woa
    lon1d_woa_to_file[:] = lon1d_woa
    lat2d_mom_to_file[:] = lat2d_mom
    lon2d_mom_to_file[:] = lon2d_mom

    unfill_to_file[:]    = sss_unfilled
    filled_s1_to_file[:] = sss_filled_step1
    filled_s2_to_file[:] = sss_filled_step2
    remapped_to_file[:]  = sss_remapped_mom
    wet_to_file[:]       = wet_mom

    f.close() 


def read_l4_sss_esacci(ds_path):
    f = Dataset(ds_path)
    delta_t  = f.variables['time'][:][0]
    sss = np.squeeze( f.variables['sss'][:] )
    sss_qc = np.squeeze( f.variables['sss_qc'][:] )
    lsc_qc = np.squeeze( f.variables['lsc_qc'][:] )
    isc_qc = np.squeeze( f.variables['isc_qc'][:] )
    f.close()
    t0 = dt.datetime(1970,1,1,0,0,0)
    t = t0 + dt.timedelta(days = int(delta_t))

    return sss, t, sss_qc, lsc_qc, isc_qc


def read_monthly_woa18_filled(ds_path,varname='SALT'):
    f = Dataset(ds_path)
    sss_12mn = f.variables[varname][:]
    f.close()

    return sss_12mn

def woa_month_to_day(woa_12mn, date):
    month_prev = date.month 
    month_next = date.month + 1 if date.month < 12 else 1
    imn_prev = month_prev - 1
    imn_next = month_next - 1

    ndays_total = calendar.monthrange(date.year,date.month)[1]
    wts_prev = 1.0 - (date.day-1)/ndays_total
    wts_next = 1.0 - wts_prev
    print("odate, wts_prev, wts_next=", date, wts_prev, wts_next)

    woa_daily = wts_prev*woa_12mn[imn_prev,:,:] + wts_next*woa_12mn[imn_next,:,:]

    return woa_daily    


def main(args):

    debug = False


    #
    # load grids info 
    #

    # read in WOA18 lon, lat
    f = Dataset(args.woa_grid_path)
    lat1d_woa = f.variables['lat'][:]
    lon1d_woa = f.variables['lon'][:]
    f.close()

    # read in L4SSS lon, lat
    f = Dataset(args.l4_grid_path)
    lat1d_l4 = f.variables['lat'][:]
    lon1d_l4 = f.variables['lon'][:]
    f.close()

    # read in tripolar mom lon, lat
    f = Dataset(args.mom_grid_path)
    lat2d_mom = f.variables['lat'][:]
    lon2d_mom = f.variables['lon'][:]
    f.close()

    f = Dataset(args.mom_lsmsk_path)
    wet2d_mom = f.variables['wet'][:]
    f.close()

    # we only generate wts to WOA18 grids within the L4 grid range; otherwise, xesmf fails to work
    lat_max_allowed = lat1d_woa[lat1d_woa<lat1d_l4.max()][-1]
    idx_lat_max_allowed = np.where(lat1d_woa==lat_max_allowed)[0][0]

    lat_min_allowed = lat1d_woa[lat1d_woa>lat1d_l4.min()][0]
    idx_lat_min_allowed = np.where(lat1d_woa==lat_min_allowed)[0][0]
    lat1d_woa_allowed = lat1d_woa[idx_lat_min_allowed:idx_lat_max_allowed+1]

    print("min_WOA18_lat can be mapped from L4 ESA: idx_woa18, val_woa18=", idx_lat_min_allowed, lat1d_woa[idx_lat_min_allowed])
    print("max_WOA18_lat can be mapped from L4 ESA: idx_woa18, val_woa18=", idx_lat_max_allowed, lat1d_woa[idx_lat_max_allowed])

    #
    # load regridder
    #

    interp_method = "bilinear"
    periodic = True

    # load the regridder: L4SSS => WOA
    grd_in = {"lon": lon1d_l4, "lat": lat1d_l4}
    grd_out = {"lon": lon1d_woa, "lat": lat1d_woa[idx_lat_min_allowed:idx_lat_max_allowed+1]}
    fn_regridder_in = os.path.abspath(args.regridder_l4_to_woa_path)
    regridder_l4_to_woa = xe.Regridder(grd_in, grd_out, interp_method, weights=fn_regridder_in, periodic=periodic)
    regridder_l4_to_woa.filename = fn_regridder_in  # a bug of xesmf 
    if debug: print(regridder_l4_to_woa)

    # load the regridder: WOA => MOM
    grd_in = {"lon": lon1d_woa, "lat": lat1d_woa}
    grd_out = {"lon": lon2d_mom, "lat": lat2d_mom}
    fn_regridder_in = os.path.abspath(args.regridder_woa_to_mom_path)
    regridder_woa_to_mom = xe.Regridder(grd_in, grd_out, interp_method, weights=fn_regridder_in, periodic=periodic)
    regridder_woa_to_mom.filename = fn_regridder_in  # a bug of xesmf 
    if debug: print(regridder_woa_to_mom)
 

    #
    # interpolate L4SSS to WOA grids
    #

    # read in monthly WOA files
    sss_12mn_woa = read_monthly_woa18_filled(args.woa18_filled_path)
    if debug:
        for i in range(0,12):
            print(i, sss_12mn_woa[i,:,:].min(), sss_12mn_woa[i,:,:].max())
 
    # read in daily L4 SSS
    sss_l4, date_l4, sss_qc, lsc_qc, isc_qc = read_l4_sss_esacci(args.l4_sss_path)
    if debug:
        print("sss_l4: shape, min, max", sss_l4.shape, sss_l4.min(), sss_l4.max())
        print("date_l4", date_l4)
    all_qc = sss_qc + lsc_qc + isc_qc


    # create daily WOA18 SSS using monthly WOA18 (maskarray)
    sss_daily_woa = woa_month_to_day(sss_12mn_woa, date_l4)

    # interp L4 SSS to WOA18 grids using regridder (sss_l4 destroyed)
    # output is interped L4 SSS with land unfilled
    QC_GOOD = 0
    sss_l4[all_qc!=QC_GOOD] = np.nan
    sss_l4[sss_l4.mask] = np.nan
    sss_l4.mask = False
    sss_l4.fill_value = 0

    wk2d = np.empty((lat1d_woa.size,lon1d_woa.size))
    wk2d[:,:] = np.nan
    wk2d[idx_lat_min_allowed:idx_lat_max_allowed+1,:] = regridder_l4_to_woa(sss_l4)

    sss_unfilled = wk2d.copy()

    # fill the grids whose nearby have no L4SSS 
    wk2d = fill_nan_grds_aux(wk2d, sss_daily_woa.data, args.radius)
    sss_filled_step1 = wk2d.copy()

    # merge 2 datasets
    missing_value = 10.0e23
    fillmask = np.isnan(wk2d)
    wk2d[fillmask] = missing_value
    iterative_fill_POP_core(var=wk2d, fillmask=fillmask, missing_value=missing_value, tol=1.e-4, ltripole=False)

    sss_filled_step2 = wk2d.copy()

    if debug: print("range of merged salinity:", wk2d.min(), wk2d.max() )


    # 
    # interpolate to MOM tripolar grids
    #
    sss_remapped_mom = regridder_woa_to_mom(wk2d)
    ocn_pts_invalid = np.isnan(sss_remapped_mom) & (wet2d_mom>0.5)
    ocn_pts_valid = (~np.isnan(sss_remapped_mom)) & (wet2d_mom>0.5)
    if np.sum(ocn_pts_invalid) > 0:
        raise Exception("invalid ocean pts found: #={}".format(np.sum(ocn_pts_invalid)))
        sys.exit(1)

    print("salinity range after remapping: ", np.min(sss_remapped_mom[ocn_pts_valid]), np.max(sss_remapped_mom[ocn_pts_valid]))
    
    write_nc_file(args.output_file_name, lat1d_woa, lon1d_woa, lat2d_mom, lon2d_mom, \
                    sss_unfilled, sss_filled_step1, sss_filled_step2, sss_remapped_mom, wet2d_mom) 

if __name__ == '__main__':
    args = parseCommandLine()
    main(args)

